/**
 * File:	include/security/dialogs.ycp
 * Package:	Security configuration
 * Summary:	Dialogs definitions
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 */

{

textdomain "security";

import "Label";
import "Popup";
import "Security";
import "Wizard";

include "security/helps.ycp";
include "security/routines.ycp";

list tree_dialogs = [ "main", "overview", "password", "boot", "login", "users", "misc", `wizardTree ];


string SecurityStatus(string option)
{
    string ret = _("Configure");

    string value = Security::Settings[option]:"";

    if (value == "yes")
    {
	ret = _("Enabled");
    }
    else if (value == "no")
    {
	ret = _("Disabled");
    }

    ret = sformat("<a href=\"%1\">%2</a>", option, ret);

    return ret;
}


string OverviewText()
{
    // open a table
    string ret = sformat("<TABLE><TR> <TD><BIG><B>%1</B></BIG></TD>
<TD ALIGN=center><BIG><B>&nbsp;&nbsp;&nbsp;&nbsp;%2&nbsp;&nbsp;&nbsp;&nbsp;</B></BIG></TD>
<TD ALIGN=center><BIG><B>&nbsp;&nbsp;&nbsp;&nbsp;%3&nbsp;&nbsp;&nbsp;&nbsp;</B></BIG></TD>
<TD></TD>
</TR> <TR></TR>",
    // table header
    _("Security Setting"), _("Status"), _("Security Status"));

    list<map> security_mapping = [
	$[
	    "label" : _("Use magic SysRq keys"),
	    "link" : SecurityStatus("ENABLE_SYSRQ"),
	    "is_secure" : (Security::Settings["ENABLE_SYSRQ"]:"" == "no")
	],
	$[
	    "label" : _("Use secure file permissions"),
	    "link" : SecurityStatus("PERMISSION_SECURITY"),
	    "is_secure" : (Security::Settings["PERMISSION_SECURITY"]:"" == "secure"
		|| Security::Settings["PERMISSION_SECURITY"]:"" == "paranoid")
	],
	$[
	    "label" : _("Remote access to the display manager"),
	    "link" : SecurityStatus("DISPLAYMANAGER_REMOTE_ACCESS"),
	    "is_secure" : (Security::Settings["DISPLAYMANAGER_REMOTE_ACCESS"]:"" == "no"),
	    "help"	: _("<P>A display manager provides for a graphical login screen and can be accessed across the network by an Xserver running on another system if so configured. The windows that are being displayed would then transmit their data across the network. If that network is not fully trusted, then the network traffic can be eavesdropped by an attacker, gaining access not only to the graphical content of the display, but also to usernames and passwords that are being used. If you don't need XDMCP for remote graphical logins, then set this to \"no\".</P>")
	],
	$[
	    "label" : _("Use current directory in root's path"),
	    "link" : SecurityStatus("CWD_IN_ROOT_PATH"),
	    "is_secure" : (Security::Settings["CWD_IN_ROOT_PATH"]:"" == "no")
	],
	$[
	    "label" : _("Use current directory in path of regular users"),
	    "link" : SecurityStatus("CWD_IN_USER_PATH"),
	    "is_secure" : (Security::Settings["CWD_IN_USER_PATH"]:"" == "no")
	],
	$[
	    "label" : _("Write back system time to the hardware clock"),
	    "link" : SecurityStatus("SYSTOHC"),
	    "is_secure" : (Security::Settings["SYSTOHC"]:"" == "yes"),
	    "help" : _("<P>Upon startup, the system time is being set from the hardware clock of the computer. By consequence, setting the hardware clock before shutting down is necessary. Consistent system time is essential for the ability of the system to create correct log messages.</P>")
	],
	$[
	    "label" : _("Always generate syslog message for cron scripts"),
	    "link" : SecurityStatus("SYSLOG_ON_NO_ERROR"),
	    "activate" : "/etc/init.d/boot.clock start",
	    "is_secure" : (Security::Settings["SYSLOG_ON_NO_ERROR"]:"" == "yes"),
	    "help" : _("<P>Malfunctions in a system are usually determined by anomalies in its behaviour. Syslog messages about events that reoccur on a regular basis are important to find causes of problems, and the absence of a single record can tell more than the absence of all log record. From this standpoint, syslog messages of system events are only useful if they are present.</P>")
	],
	$[
	    // FIXME
	    "label" : _("DHCPD_RUN_CHROOTED"),
	    "link" : SecurityStatus("DHCPD_RUN_CHROOTED"),
	    "is_secure" : (Security::Settings["DHCPD_RUN_CHROOTED"]:"" == "yes"),
	    "activate"	: "/etc/init.d/dhcpd restart",
	    "help" : _("<P>Chroot execution environments are used to constrain a process to only those files that it needs by placing them in a separate subdirectory and running the process with a changed root (chroot) set to that directory.</P>")
	],
	$[
	    // FIXME
	    "label" : _("DHCPD_RUN_AS"),
	    "link" : SecurityStatus("DHCPD_RUN_AS"),
	    "is_secure" : (Security::Settings["DHCPD_RUN_AS"]:"" == "dhcp"),
	    "help" : _("<P>DHCP client daemon should run as the user \"dhcpd\" to minimize the possible threat if the service is found vulnerable to a weakness in its program code. Please note that dhcpd must not run as root or with the CAP_SYS_CHROOT capability for the chroot execution confinement to be effective.</P>")
	],
	$[
	    "label" : _("Disable root login in the display manager"),
	    "link" : SecurityStatus("DISPLAYMANAGER_ROOT_LOGIN_REMOTE"),
	    "is_secure" : (Security::Settings["DISPLAYMANAGER_ROOT_LOGIN_REMOTE"]:"" == "no"),
	    "help" : _("<P>Administrators should care to not log on as root into an Xwindows session to minimize the usage of the root privileges. This option does not help against careless administrators, but shall prevent attackers to be able to log on as root through the displaymanager if they guess or otherwise acquire the password.</P>")
	],
	$[
	    "label" : _("Disable remote access to the X server"),
	    "link" : SecurityStatus("DISPLAYMANAGER_XSERVER_TCP_PORT_6000_OPEN"),
	    "is_secure" : (Security::Settings["DISPLAYMANAGER_XSERVER_TCP_PORT_6000_OPEN"]:"" == "no"),
	    "help" : _("<P>Xwindows clients, e.g. programs that open a window on your display, connect to the Xserver that runs on the physical machine. Programs can also run on a different system and can display their content on the Xserver through network connections. To enable this, this variable needs to be set to \"yes\", which makes the Xserver listen on a port 6000 plus the display number. Since the network traffic is transferred unencrypted and therefore subject to network sniffing, and since another port held open by a program - here the Xserver - opens attack options, the secure setting is \"no\". To display Xwindows clients across a network, the use of secure shell (ssh) is recommended, which allows the Xwindows client to connect to the Xserver through the encrypted ssh connection.</P>")
	],
	$[
	    "label" : _("Remote access to the email delivery subsystem"),
	    "link" : SecurityStatus("SMTPD_LISTEN_REMOTE"),
	    "is_secure" : (Security::Settings["SMTPD_LISTEN_REMOTE"]:"" == "no"),
	    "help" : _("<P>The email delivery subsystem is always started. However, it does not expose itself to the outside of the system by default because it does not listen on the SMTP network port 25. If you don't deliver emails to your system through the SMTP protocol, then set this to \"no\".</P>"),
	    // FIXME
	    "activate" : "SuSEconfig AND (/etc/init.d/sendmail OR /etc/init.d/postfix) restart"
	],
	$[
	    "label" : _("Disable service restart on update"),
	    "link" : SecurityStatus("DISABLE_RESTART_ON_UPDATE"),
	    "is_secure" : (Security::Settings["DISABLE_RESTART_ON_UPDATE"]:"" == "no"),
	    "help" : _("<P>Upon update of a package that contains a service that is currently running, the system will restart the service for the package changes to take effect. This may not be in line with site specific administrative rules, and it may not be practical either in your environment. However, it is safe to activate changes as soon as they are available, making \"no\" more secure.</P>"),
	],
	$[
	    "label" : _("Disable service stop on removal"),
	    "link" : SecurityStatus("DISABLE_STOP_ON_REMOVAL"),
	    "is_secure" : (Security::Settings["DISABLE_STOP_ON_REMOVAL"]:"" == "no"),
	    "help" : _("<P>If a package containing a service that is currently running is being deinstalled, then the service is being stopped before the files of the package are being removed. This makes sense in most cases, and it is safe to do, considering that many services neither need their binaries accessible in the filesystem, nor their configuration files. These services would just continue to run until the services are stopped, e.g. running daemons are killed. This setting should only be changed if there is a specific reason to do so.</P>"),
	],
	$[
	    "label" : _("Enable TCP syncookies"),
	    "link" : SecurityStatus("IP_TCP_SYNCOOKIES"),
	    "is_secure" : (Security::Settings["IP_TCP_SYNCOOKIES"]:"" == "yes"),
	    "help" : _("<P>A system can be overwhelmed with numerous connection attempts so that the system runs out of memory, leading to a Denial of Service (DoS) vulnerability. The use of syncookies is a method that can help in such situations, but in configurations with a very large number of legitimate connection attempts from one source the \"yes\" setting can bring problems with denied TCP connections under high load. Still, for most environments, the syncookies are the first line of defense against SYN flood DoS attacks, so the secure setting is \"yes\".</P>"),
	    "activate": "/etc/init.d/boot.ipconfig start"
	],
	$[
	    "label" : _("Disable IPv4 forwarding"),
	    "link" : SecurityStatus("IP_FORWARD"),
	    "is_secure" : (Security::Settings["IP_FORWARD"]:"" == "no"),
	    "help" : _("<P>IP forwarding means to pass on network packets that have been received, but that are not destined for one of the system's configured network interfaces, eg network interface addresses. If a system forwards network traffic on ISO/OSI layer 3, it is called a router. If you do not need that routing functionality, then set this to \"no\", which is the secure setting.</P>") + _("</P>This setting applies to IPV4 only.</P>"),
	    "activate": "/etc/init.d/boot.ipconfig start"
	],
	$[
	    "label" : _("Disable IPv6 forwarding"),
	    "link" : SecurityStatus("IPV6_FORWARD"),
	    "is_secure" : (Security::Settings["IPV6_FORWARD"]:"" == "no"),
	    "help" : _("<P>IP forwarding means to pass on network packets that have been received, but that are not destined for one of the system's configured network interfaces, eg network interface addresses. If a system forwards network traffic on ISO/OSI layer 3, it is called a router. If you do not need that routing functionality, then set this to \"no\", which is the secure setting.</P>") + _("</P>This setting applies to IPV6 only.</P>"),
	    "activate": "/etc/init.d/boot.ipconfig start"
	],
    ];

    foreach(map setting, security_mapping,
	{
	    string current_value = Security::Settings[setting["name"]:""]:"";

	    // add one line for each security setting
	    ret = ret + sformat("<TR><TD>%1&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD ALIGN=center>%2</TD><TD ALIGN=center>&nbsp;&nbsp;&nbsp;%3</TD></TR>",
		setting["label"]:"",
		setting["link"]:"",
		setting["is_secure"]:false ?
		    "<SUP><FONT COLOR=green SIZE=20>✔</FONT></SUP>" : "<FONT COLOR=red SIZE=20><SUP>✘</SUP></FONT>"
	    );
	}
    );

    // close the table
    ret = ret + "</TABLE>";

    return ret;
}

// mapping for "Enable" and "Disable" links
// current value -> new value
map link_value_mapping = $[
    "yes" : "no",
    "no"  : "yes"
];

// mapping for "Configure" links
// config name -> dialog name
map link_config_mapping = $[
    "PERMISSION_SECURITY" : "misc"
];

define any OverviewDialog()
{
    /* Overview dialog caption */
    string caption = _("Security Overview");
    string help = HELPS["overview"]:"";

    term contents = `RichText(`id(`rtext), OverviewText());

    Wizard::SetContentsButtons(caption, contents, help,
	    Label::BackButton(), Label::OKButton());

    Wizard::HideBackButton();
    Wizard::SetAbortButton( `abort, Label::CancelButton() );

    // select the dialog in the tree navigation
    Wizard::SelectTreeItem("overview");

    any ret = nil;
    while(true) {
	ret = UI::UserInput();

	/* abort? */
	if(ret == `abort || ret == `cancel) {
	    if(ReallyAbort()) break;
	    else continue;
	}
	else if(ret == `back || ret == `next || contains(tree_dialogs, ret)) {
	    break;
	}
	// user clicked a link in the richtext
	else if (is(ret, string) && haskey(Security::Settings, ret))
	{
	    y2milestone("Clicked %1 link", ret);

	    string current_value = Security::Settings[(string)ret]:"";

	    string new_value = link_value_mapping[current_value]:current_value;

	    // set the new value and refresh the overview
	    if (haskey(link_value_mapping, current_value) && new_value != current_value)
	    {
		y2milestone("New value for %1: %2", ret, new_value);
		Security::Settings[(string)ret] = new_value;
		// the config has been changed
		Security::SetModified();

		UI::ChangeWidget(`id(`rtext), `Value, OverviewText());
	    }
	    else if (haskey(link_config_mapping, ret))
	    {
		string new_dialog = link_config_mapping[ret]:"";

		y2milestone("Switching to dialog %1", new_dialog);
		return new_dialog;
	    }
	    else
	    {
		y2error("Unknown action for link %1", ret);
	    }
	}
	else {
	    y2error("Unexpected return code: %1", ret);
	    continue;
	}
    }

    return ret;
}

/**
 * Boot dialog
 * @return dialog result
 */
define any BootDialog() ``{

    /* Boot dialog caption */
    string caption = _("Boot Settings");
    string help = HELPS["boot"]:"";

    /* Boot dialog contents */
    term contents = `HVCenter(`HVSquash(`HBox(
	`HSpacing(5),
	`VBox(
	    `VSpacing(2),
	    /* Frame label */
	    `Frame(_("Boot Permissions"),`HBox(
		`HSpacing(3),
		`VBox(
		    `VSpacing(1),
		    settings2widget("CONSOLE_SHUTDOWN"),
		    `VSpacing(1.0),
		    settings2widget("DISPLAYMANAGER_SHUTDOWN"),
		    `VSpacing(1)
		),
		`HSpacing(3)
	    )),
	    `VSpacing(2)
	),
	`HSpacing(5)
    )));

    Wizard::SetContentsButtons(caption, contents, help,
	    Label::BackButton(), Label::OKButton());

    Wizard::HideBackButton();
    Wizard::SetAbortButton( `abort, Label::CancelButton() );

    // select the dialog in the tree navigation
    Wizard::SelectTreeItem("boot");

    any ret = nil;
    while(true) {
	ret = UI::UserInput();

	/* abort? */
	if(ret == `abort || ret == `cancel) {
	    if(ReallyAbort()) break;
	    else continue;
	}
	else if(ret == `back || ret == `next || contains(tree_dialogs, ret)) {
	    break;
	}
	else {
	    y2error("Unexpected return code: %1", ret);
	    continue;
	}
    }

    if(ret == `next || contains(tree_dialogs, ret)) {
	widget2settings("CONSOLE_SHUTDOWN");
	widget2settings("DISPLAYMANAGER_SHUTDOWN");
    }

    return ret;
}

/**
 * Misc dialog
 * @return dialog result
 */
define any MiscDialog() ``{

    /* Misc dialog caption */
    string caption = _("Miscellaneous Settings");
    string help = HELPS["misc"]:"";

    /* Misc dialog contents */
    term contents = `VBox(
	VSeparator(),
	settings2widget("PERMISSION_SECURITY"),
	`VSpacing(1.0),
	settings2widget("RUN_UPDATEDB_AS"),
	`VSpacing(1.0),
	settings2widget("CWD_IN_ROOT_PATH"),
	VSeparator(),
	settings2widget("CWD_IN_USER_PATH"),
	`VSpacing(1.0),
	settings2widget("ENABLE_SYSRQ"),
	`VSpacing(1.8)
    );
    contents = `HVCenter(`HVSquash(`HBox(`HSpacing(5),`VBox(`VSpacing(2),`ReplacePoint(`id(`rp_main),contents),`VSpacing(2)),`HSpacing(5))));

    Wizard::SetContentsButtons(caption, contents, help,
	    Label::BackButton(), Label::OKButton());

    Wizard::HideBackButton();
    Wizard::SetAbortButton( `abort, Label::CancelButton() );

    // select the dialog in the tree navigation
    Wizard::SelectTreeItem("misc");

    any ret = nil;
    while(true) {
	ret = UI::UserInput();

	/* abort? */
	if(ret == `abort || ret == `cancel) {
	    if(ReallyAbort()) break;
	    else continue;
	}
	else if(ret == `back) {
	    break;
	}
	else if(ret == `next || contains(tree_dialogs, ret)) {
	    /* check_* */
	    break;
	}
	else {
	    y2error("Unexpected return code: %1", ret);
	    continue;
	}
    }

    if(ret == `next || contains(tree_dialogs, ret)) {
	widget2settings("PERMISSION_SECURITY");
	widget2settings("CWD_IN_ROOT_PATH");
	widget2settings("CWD_IN_USER_PATH");
	widget2settings("RUN_UPDATEDB_AS");
	widget2settings("ENABLE_SYSRQ");
    }

    return ret;
}

/**
 * Password dialog
 * @return dialog result
 */
define any PassDialog() ``{

    /* Password dialog caption */
    string caption = _("Password Settings");
    string help = HELPS["password"]:"";

    /* Password dialog contents */
    term contents = `VBox(
	/* Frame label */
	XFrame(0.3,0.15,_("Checks"),`VBox(
	    settings2widget("PASSWD_USE_CRACKLIB"),
	    VSeparator(),
	    settings2widget("OBSCURE_CHECKS_ENAB"),
	    VSeparator(),
	    settings2widget("PASSWD_REMEMBER_HISTORY"),
	    VSeparator()
	)),
	`VSpacing(0.4),
	settings2widget("PASSWD_ENCRYPTION"),
	`VSpacing(0.4),
	settings2widget("PASS_MIN_LEN"),
	`VSpacing(0.4),
	/* Frame label */
	`Frame(_("Password Age"),`HBox(
	    `HSpacing(0.4),
	    settings2widget("PASS_MIN_DAYS"),
	    `HSpacing(0.4),
	    settings2widget("PASS_MAX_DAYS"),
	    `HSpacing(0.4)
	)),
	`VSpacing(0.15),
	settings2widget("PASS_WARN_AGE"),
	`VSpacing(0.0)
    );
    contents = `HVCenter(`HVSquash(`HBox(`HSpacing(5),`VBox(`VSpacing(2),`ReplacePoint(`id(`rp_main),contents),`VSpacing(2)),`HSpacing(5))));

    Wizard::SetContentsButtons(caption, contents, help,
	    Label::BackButton(), Label::OKButton());

    Wizard::HideBackButton();
    Wizard::SetAbortButton( `abort, Label::CancelButton() );

    // select the dialog in the tree navigation
    Wizard::SelectTreeItem("password");

    any ret = nil;
    while(true) {
	ret = UI::UserInput();

	/* abort? */
	if(ret == `abort || ret == `cancel) {
	    if(ReallyAbort()) break;
	    else continue;
	}
	else if(ret == `back) {
	    break;
	}
	else if(ret == `next || contains(tree_dialogs, ret)) {
	    /* check_* */
	    if(checkMinMax("PASS_MIN_DAYS","PASS_MAX_DAYS") != true) {
		/* Popup text */
		Popup::Error(_("The minimum number of days cannot be larger
than the maximum."));
		continue;
	    }
	    string enc	=
		(string) UI::QueryWidget(`id("PASSWD_ENCRYPTION"), `Value);
	    integer min = (integer) UI::QueryWidget(`id("PASS_MIN_LEN"),`Value);
	    if (min > Security::PasswordMaxLengths[enc]:8)
	    {
		// Popup text, %1 is number
		Popup::Error (sformat (_("The minimum password length cannot be larger than the maximum.
The maximum password length for the selected encryption method is %1."),
		Security::PasswordMaxLengths[enc]:8));
		continue;
	    }
	    break;
	}
	else if (ret != "PASSWD_ENCRYPTION") {
	    y2error("Unexpected return code: %1", ret);
	    continue;
	}
    }

    if(ret == `next || contains(tree_dialogs, ret)) {
	widget2settings("PASS_MIN_DAYS");
	widget2settings("PASS_MAX_DAYS");
	widget2settings("PASS_MIN_LEN");
	widget2settings("PASSWD_USE_CRACKLIB");
	widget2settings("OBSCURE_CHECKS_ENAB");
	widget2settings("PASS_WARN_AGE");
	widget2settings("PASSWD_ENCRYPTION");
	widget2settings("PASSWD_REMEMBER_HISTORY");
    }

    return ret;
}

/**
 * Login dialog
 * @return dialog result
 */
define any LoginDialog() ``{

    /* Login dialog caption */
    string caption = _("Login Settings");
    string help = HELPS["login"]:"";

    /* Login dialog contents */
    term contents = `VBox(
	/* Frame label */
	XFrame(3.0,1.0,_("Login"),`VBox(
	    //VSeparator(),
	    settings2widget("FAIL_DELAY"),
	    //VSeparator(),
	    `VSpacing(0.5),
	    settings2widget("LASTLOG_ENAB"),
	    VSeparator(),
	    settings2widget("DISPLAYMANAGER_REMOTE_ACCESS")
	    //VSeparator()
	))
	//,`VSpacing(1.7)
    );
    contents = `HVCenter(`HVSquash(`HBox(`HSpacing(5),`VBox(`VSpacing(2),`ReplacePoint(`id(`rp_main),contents),`VSpacing(2)),`HSpacing(5))));

    Wizard::SetContentsButtons(caption, contents, help,
	    Label::BackButton(), Label::OKButton());

    Wizard::HideBackButton();
    Wizard::SetAbortButton( `abort, Label::CancelButton() );

    // select the dialog in the tree navigation
    Wizard::SelectTreeItem("login");

    any ret = nil;
    while(true) {
	ret = UI::UserInput();

	/* abort? */
	if(ret == `abort || ret == `cancel) {
	    if(ReallyAbort()) break;
	    else continue;
	}
	else if(ret == `back) {
	    break;
	}
	else if(ret == `next || contains(tree_dialogs, ret)) {
	    /* check_* */
	    break;
	}
	else {
	    y2error("Unexpected return code: %1", ret);
	    continue;
	}
   }

    if(ret == `next || contains(tree_dialogs, ret)) {
	widget2settings("LASTLOG_ENAB");
	widget2settings("FAIL_DELAY");
	widget2settings("DISPLAYMANAGER_REMOTE_ACCESS");
    }

    return ret;
}

/* EOF */
}
